import axios from "axios";
import Route from "../models/Route.js";
import RouteStop from "../models/RouteStop.js";
import Stop from "../models/Stop.js";
import mongoose from "mongoose";






// üü¢ T·∫°o tuy·∫øn t·ª± ƒë·ªông
export const createRouteAuto = async (req, res) => {
  try {
    const { name, stopIds } = req.body; // stopIds = ["stopId1", "stopId2", ...]

    if (!stopIds || stopIds.length < 2)
      return res.status(400).json({ message: "C·∫ßn √≠t nh·∫•t 2 ƒëi·ªÉm d·ª´ng!" });

    // L·∫•y Stop chi ti·∫øt t·ª´ DB
    const stops = await Stop.find({ _id: { $in: stopIds }, status: "active" });
    if (stops.length !== stopIds.length)
      return res.status(400).json({ message: "M·ªôt s·ªë stop kh√¥ng t·ªìn t·∫°i ho·∫∑c inactive!" });

    // T·∫°o route m·ªõi
    const route = new Route({
      name,
      start_point: stopIds[0],
      end_point: stopIds[stopIds.length - 1],
    });

    // üõ£ Call Routing API ƒë·ªÉ l·∫•y path
    const coordinates = stops.map(s => s.location.coordinates); // [[lng, lat], ...]
    
    // V√≠ d·ª•: gi·∫£ l·∫≠p path tr·ª±c ti·∫øp theo stop (th·ª±c t·∫ø g·ªçi API Google/Mapbox)
    route.path.coordinates = coordinates;
    
    await route.save();

    // T·∫°o RouteStop theo th·ª© t·ª±
    const routeStops = [];
    for (let i = 0; i < stopIds.length; i++) {
      const rs = new RouteStop({
        route_id: route._id,
        stop_id: stopIds[i],
        order_number: i + 1,
        estimated_arrival: null, // c√≥ th·ªÉ t√≠nh sau
      });
      await rs.save();
      routeStops.push(rs);
    }

    res.status(201).json({
      message: "T·∫°o tuy·∫øn ƒë∆∞·ªùng & RouteStop t·ª± ƒë·ªông th√†nh c√¥ng!",
      route,
      routeStops,
    });
  } catch (error) {
    console.error("‚ùå L·ªói khi t·∫°o tuy·∫øn t·ª± ƒë·ªông:", error);
    res.status(500).json({ message: "L·ªói server!", error: error.message });
  }
};

// üü¢ L·∫•y t·∫•t c·∫£ tuy·∫øn ƒë∆∞·ªùng
export const getAllRoutes = async (req, res) => {
    try {
        const routes = await Route.find()
            .populate("start_point", "name location")
            .populate("end_point", "name location");

        res.status(200).json(routes);
    } catch (error) {
        console.error("‚ùå L·ªói khi l·∫•y danh s√°ch tuy·∫øn:", error);
        res.status(500).json({ message: "L·ªói server!", error: error.message });
    }
};

export const getRouteById = async (req, res) => {
    const { id } = req.params;

    // ‚úÖ Ki·ªÉm tra id c√≥ h·ª£p l·ªá kh√¥ng
    if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({ message: "ID route kh√¥ng h·ª£p l·ªá!" });
    }

    try {
        const route = await Route.findById(id)
            .populate("start_point", "name location")
            .populate("end_point", "name location");

        if (!route) return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y tuy·∫øn!" });

        const stops = await RouteStop.find({ route_id: id })
            .populate("stop_id", "name location")
            .sort("order_number");

        res.status(200).json({ route, stops });
    } catch (error) {
        console.error("‚ùå L·ªói khi l·∫•y chi ti·∫øt tuy·∫øn:", error);
        res.status(500).json({ message: "L·ªói server!", error: error.message });
    }
};

// üü¢ T·∫°o m·ªõi tuy·∫øn ‚Äî g·ªçi API ƒë·ªãnh tuy·∫øn ƒë·ªÉ l·∫•y path
export const createRoute = async (req, res) => {
    try {
        const { name, stop_ids } = req.body; // stop_ids l√† m·∫£ng theo th·ª© t·ª± [A, B, C, D]

        if (!stop_ids || stop_ids.length < 2) {
            return res.status(400).json({ message: "Ph·∫£i c√≥ √≠t nh·∫•t 2 ƒëi·ªÉm d·ª´ng!" });
        }

        // L·∫•y th√¥ng tin to·∫° ƒë·ªô c√°c ƒëi·ªÉm
        const stops = await Stop.find({ _id: { $in: stop_ids } });

        if (stops.length !== stop_ids.length) {
            return res.status(400).json({ message: "M·ªôt s·ªë ƒëi·ªÉm d·ª´ng kh√¥ng t·ªìn t·∫°i!" });
        }

        // üîπ Chu·∫©n b·ªã to·∫° ƒë·ªô theo th·ª© t·ª± ƒë√£ ch·ªçn
        const coordinates = stop_ids.map((id) => {
            const stop = stops.find((s) => s._id.toString() === id);
            return stop.location.coordinates;
        });

        // üó∫Ô∏è G·ªçi API Mapbox Directions (ho·∫∑c Google n·∫øu mu·ªën)
        const mapboxToken = process.env.MAPBOX_TOKEN; // c·∫ßn c√≥ token trong .env
        const coordStr = coordinates.map((c) => `${c[0]},${c[1]}`).join(";");
        const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coordStr}?geometries=geojson&access_token=${mapboxToken}`;

        const { data } = await axios.get(url);

        if (!data.routes || !data.routes[0]) {
            return res.status(400).json({ message: "Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu tuy·∫øn ƒë∆∞·ªùng!" });
        }

        const geometry = data.routes[0].geometry;

        // üîπ T·∫°o m·ªõi route
        const newRoute = new Route({
            name,
            start_point: stop_ids[0],
            end_point: stop_ids[stop_ids.length - 1],
            path: geometry,
        });

        await newRoute.save();

        // üîπ L∆∞u c√°c ƒëi·ªÉm d·ª´ng v√†o RouteStops
        const routeStops = stop_ids.map((stopId, index) => ({
            route_id: newRoute._id,
            stop_id: stopId,
            order_number: index + 1,
        }));

        await RouteStop.insertMany(routeStops);

        res.status(201).json({
            message: "‚úÖ T·∫°o tuy·∫øn m·ªõi th√†nh c√¥ng!",
            route: newRoute,
        });
    } catch (error) {
        console.error("‚ùå L·ªói khi t·∫°o tuy·∫øn:", error);
        res.status(500).json({ message: "L·ªói server khi t·∫°o tuy·∫øn!", error: error.message });
    }
};

// üü° C·∫≠p nh·∫≠t tuy·∫øn
export const updateRoute = async (req, res) => {
    try {
        const { id } = req.params;
        const { name, status } = req.body;

        const updated = await Route.findByIdAndUpdate(
            id,
            { name, status },
            { new: true }
        );

        if (!updated) return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y tuy·∫øn!" });

        res.status(200).json({
            message: "‚úÖ C·∫≠p nh·∫≠t tuy·∫øn th√†nh c√¥ng!",
            data: updated,
        });
    } catch (error) {
        console.error("‚ùå L·ªói khi c·∫≠p nh·∫≠t tuy·∫øn:", error);
        res.status(500).json({ message: "L·ªói server khi c·∫≠p nh·∫≠t!", error: error.message });
    }
};

// üî¥ Xo√° tuy·∫øn
export const deleteRoute = async (req, res) => {
    try {
        const { id } = req.params;

        const deleted = await Route.findByIdAndDelete(id);
        if (!deleted) return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y tuy·∫øn!" });

        // Xo√° lu√¥n c√°c RouteStops li√™n quan
        await RouteStop.deleteMany({ route_id: id });

        res.status(200).json({ message: "üóëÔ∏è Xo√° tuy·∫øn th√†nh c√¥ng!" });
    } catch (error) {
        console.error("‚ùå L·ªói khi xo√° tuy·∫øn:", error);
        res.status(500).json({ message: "L·ªói server khi xo√° tuy·∫øn!", error: error.message });
    }
};
